
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Design Principles &#8212; Auditree Framework 1.21.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="OSCAL Support" href="oscal.html" />
    <link rel="prev" title="Quick Start" href="quick-start.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="oscal.html" title="OSCAL Support"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="quick-start.html" title="Quick Start"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Auditree Framework 1.21.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Design Principles</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="design-principles">
<span id="id1"></span><h1>Design Principles<a class="headerlink" href="#design-principles" title="Permalink to this headline">¶</a></h1>
<p>The tool is divided in two main parts:</p>
<ul class="simple">
<li><p><cite>Fetch</cite> mode: the tool will collect all the evidence that is
required by checks. Note that during this phase <cite>nothing</cite> is
checked, only evidence collection is performed. Fetchers typically need
access to third-party services using specific credentials.</p></li>
<li><p><cite>Check</cite> mode: run checks against the evidence stored in the local evidence
locker. During this phase, checks can use the evidence that fetchers
gathered in the previous “fetch” phase. They can also generate reports and
create notifications. Checks <strong>must not</strong> access third-party services
for gathering information. It is however permissible for check fixer
functions to access third-party services.</p></li>
</ul>
<p>Both fetch and check phases are run by unittest. This is very convenient
as fetchers and checks are loaded automatically by <code class="docutils literal notranslate"><span class="pre">unittest</span></code>.</p>
<section id="evidence">
<h2>Evidence<a class="headerlink" href="#evidence" title="Permalink to this headline">¶</a></h2>
<p>Fetchers and checks manage evidence. We have defined five types of
evidence (see <a class="reference internal" href="compliance.html#module-compliance.evidence" title="compliance.evidence"><code class="xref py py-mod docutils literal notranslate"><span class="pre">compliance.evidence</span></code></a>):</p>
<ul class="simple">
<li><p><a class="reference internal" href="compliance.html#compliance.evidence.RawEvidence" title="compliance.evidence.RawEvidence"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawEvidence</span></code></a>: Gathered by
fetchers and used by checks as <em>input</em>. For example, a list of users in
GitHub.  If necessary, raw evidence can be
<a class="reference external" href="https://complianceascode.github.io/auditree-framework/evidence-partitioning.html">partitioned</a> if the content is valid JSON.  All evidence
content is stored as text by default but raw evidence content can be stored
as binary by setting the <code class="docutils literal notranslate"><span class="pre">binary_content=True</span></code> keyword argument key/value
pair when constructing a <code class="docutils literal notranslate"><span class="pre">RawEvidence</span></code> object.</p></li>
<li><p><a class="reference internal" href="compliance.html#compliance.evidence.DerivedEvidence" title="compliance.evidence.DerivedEvidence"><code class="xref py py-class docutils literal notranslate"><span class="pre">DerivedEvidence</span></code></a>: Gathered/Generated by
fetchers and used by checks as <em>input</em>.  Derived evidence is useful for
those cases when a fetcher needs other evidence to perform computations
over data collected in order to generate a new evidence. This new
evidence is considered <cite>derived</cite> in the sense that its data is not the
same as the source.</p></li>
<li><p><a class="reference internal" href="compliance.html#compliance.evidence.TmpEvidence" title="compliance.evidence.TmpEvidence"><code class="xref py py-class docutils literal notranslate"><span class="pre">TmpEvidence</span></code></a>: Gathered by
fetchers and used by checks as <em>input</em>. This type of evidence is similar to
RawEvidence but it is never get pushed to the remote git repository. This is
useful for evidence that contains passwords or credentials.</p></li>
<li><p><a class="reference internal" href="compliance.html#compliance.evidence.ExternalEvidence" title="compliance.evidence.ExternalEvidence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExternalEvidence</span></code></a>: Planted in the locker
with <a class="reference external" href="https://github.com/ComplianceAsCode/auditree-plant">plant</a>
and used by checks as <em>input</em>. For example, a list of users in GitHub.</p></li>
<li><p><a class="reference internal" href="compliance.html#compliance.evidence.ReportEvidence" title="compliance.evidence.ReportEvidence"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReportEvidence</span></code></a>: may be
generated by checks. For instance, a report showing missing GitHub users.</p></li>
</ul>
<p>See <a class="reference internal" href="#fetchers"><span class="std std-ref">Compliance Fetchers</span></a> section for conventions and expectations with
respect to modifying RawEvidence.</p>
<p>All evidence has a settable <code class="docutils literal notranslate"><span class="pre">ttl</span></code> (Time To Live) property that defines how
long an evidence should be considered valid. For instance, if new data is
generated on a daily basis then evidence gathered for that data should only be
valid for 1 day.  For this reason, any check trying to use evidence with an
expired <code class="docutils literal notranslate"><span class="pre">ttl</span></code> will error.</p>
<p>All evidence has an <code class="docutils literal notranslate"><span class="pre">is_empty</span></code> property that defines an evidence’s empty
state.  This provides value when monitoring evidence content for completness.
The property can be overridden to define “empty” for any given evidence.  By default evidence is considered empty if it has no content, is all whitespace,
or if it is JSON and is an empty dictionary or list (<code class="docutils literal notranslate"><span class="pre">{}</span></code>, <code class="docutils literal notranslate"><span class="pre">[]</span></code>).</p>
</section>
<section id="evidence-locker">
<h2>Evidence Locker<a class="headerlink" href="#evidence-locker" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Locker</span></code> is a helper for storing evidence securely in a Git
repository. <a class="reference internal" href="compliance.html#compliance.locker.Locker" title="compliance.locker.Locker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Locker</span></code></a> is responsible
for:</p>
<ul>
<li><p>Storing evidence files properly in Git so changes can be tracked.  Provide
the <code class="docutils literal notranslate"><span class="pre">repo_url</span></code> to define the remote evidence locker location and
the git configuration through <code class="docutils literal notranslate"><span class="pre">gitconfig</span></code> parameter as a
dictionary. You can provide the user full name, email and also
activate commit GPG siging (which is the recommended way). As an
example of this, your config file might look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;locker&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;gitconfig&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;commit&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;gpgsign&quot;</span><span class="p">:</span> <span class="n">true</span><span class="p">},</span>
      <span class="s2">&quot;gpg&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;program&quot;</span><span class="p">:</span> <span class="s2">&quot;gpg2&quot;</span><span class="p">},</span>
      <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;signingKey&quot;</span><span class="p">:</span> <span class="s2">&quot;AABBCCDD&quot;</span><span class="p">,</span>
        <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="s2">&quot;compliance-robot@my-org.com&quot;</span><span class="p">,</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;compliance-robot&quot;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All <a class="reference external" href="https://git-scm.com/docs/git-config">git options</a> are
accepted. Set your git configuration with care, paying special
attention to those attributes within the <code class="docutils literal notranslate"><span class="pre">core</span></code> section.</p>
</li>
<li><p>Validating the <code class="docutils literal notranslate"><span class="pre">ttl</span></code> for a given evidence.  An optional evidence
<code class="docutils literal notranslate"><span class="pre">ttl</span></code> tolerance value can be configured to be applied during
fetcher execution.  This value (in seconds) tells fetchers to
retrieve evidence that is nearly but not yet stale.  If no value is
supplied then fetchers will only retrieve new evidence after <code class="docutils literal notranslate"><span class="pre">ttl</span></code>
has expired.  You can set the optional <code class="docutils literal notranslate"><span class="pre">ttl_tolerance</span></code> value in
your configuration JSON file like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;locker&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ttl_tolerance&quot;</span><span class="p">:</span> <span class="mi">3600</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Check execution is not affected by this optional
tolerance value because checks should only interact with evidence that
is fresh (not stale).</p>
</li>
<li><p>It’s generally a good idea to regularly “archive” an evidence locker in
favor of a fresh one.  A yearly locker archive/refresh is a good guideline
to follow.  However in cases where checks may need to reference historical
evidence, using a new locker will cause undesirable results in the short
term.  For cases like this referencing historical evidence from a previous
locker is possible by using the <code class="docutils literal notranslate"><span class="pre">prev_repo_url</span></code> option.  With that
option set, a check that is unable to find historical evidence in the
current evidence locker will be able to download the previous locker and
look for the historical evidence there.  Setting the option in your configuration JSON file would look
similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;locker&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;prev_repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo-old&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The previous locker will no longer be downloaded once the new locker is
primed with enough historical evidence to support all checks.</p>
</li>
<li><p>A locker can grow large, causing CI/CD jobs to run longer than desired
due to locker download time.  So in addition to a sound locker archiving
strategy, it is also possible to configure your locker to only download
recent commits by using the <code class="docutils literal notranslate"><span class="pre">shallow_days</span></code> option.  Setting the
option in your configuration JSON file would look similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;locker&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;prev_repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo-old&quot;</span><span class="p">,</span>
    <span class="s2">&quot;shallow_days&quot;</span><span class="p">:</span> <span class="mi">10</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">shallow_days</span></code> is supplied, only commits since the current date minus
the number of days set as <code class="docutils literal notranslate"><span class="pre">shallow_days</span></code> are included in the locker
download.  The option applies to both the locker and the previous locker (if
applicable).</p>
</li>
<li><p>Remote hosting services (Github, Gitlab, BitBucket) typically have file size
limitations that can vary from service instance to service instance.
Exceeding a maximum file size will in turn cause the service managing your
evidence locker to reject a remote locker Git push request.  Unfortunately
rejection notices from a service aren’t always the most descriptive so it
often isn’t clear why your push request was rejected.  To that end, prior to
a remote push, the framework will log a list of “largely sized” files.  The
large file size threshold is configurable and can be set by using the
<code class="docutils literal notranslate"><span class="pre">large_file_threshold</span></code> option.  The value is in bytes and defaults to
50 MB.  Setting the option in your configuration JSON file would look similar
to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;locker&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;repo_url&quot;</span><span class="p">:</span> <span class="s2">&quot;https://github.com/my-org/my-evidence-repo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;large_file_threshold&quot;</span><span class="p">:</span> <span class="mi">50000000</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This should hopefully add some detail to a remote Git push rejection.</p>
</li>
</ul>
</section>
<section id="compliance-fetchers">
<span id="fetchers"></span><h2>Compliance Fetchers<a class="headerlink" href="#compliance-fetchers" title="Permalink to this headline">¶</a></h2>
<p>All the fetchers should be implemented as a child class of
<a class="reference internal" href="compliance.html#compliance.fetch.ComplianceFetcher" title="compliance.fetch.ComplianceFetcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplianceFetcher</span></code></a>. Note that this
class provides a set of methods that could be useful for saving some
code.</p>
<p>The run-time engine will collect all the fetchers and run all of them
when <cite>–fetch</cite> option is provided.</p>
<p>The typical implementation of a <code class="docutils literal notranslate"><span class="pre">ComplianceFetcher</span></code> would be like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">raw_evidence</span> <span class="o">=</span> <span class="n">fetch</span><span class="p">(</span><span class="s1">&#39;the evidence&#39;</span><span class="p">)</span>
<span class="n">locker</span><span class="o">.</span><span class="n">add_evidence</span><span class="p">(</span><span class="n">raw_evidence</span><span class="p">)</span>
</pre></div>
</div>
<p>A fetcher should collect the data (from whatever source) and then store
it straight to the locker. Thus, the fetcher <em>should not</em> modify any data
from the source to keep it <strong>raw</strong>.</p>
<p>However, there are some changes that can be applied and do not modify
the original meaning of the generated raw evidence. The aim of these
exception are to avoid committing data into the locker that has not changed.</p>
<p>A few examples of what it is allowed:</p>
<ul class="simple">
<li><p>Sorting (e.g. sort a JSON blob by keys)</p></li>
<li><p>Modifying data in a equivalent way. For instance, storing seconds
instead of milli-seconds. A good rule of thumb for this could be:
<em>from the test code, would I be able to re-build the original value
of the raw evidence?</em>. If the answer is <em>Yes</em>, then it is likely
that the modification is fine.</p></li>
</ul>
<p>In any case, any modification of a new raw evidence <strong>must</strong> be
approved and agreed by the reviewers. By default, do <strong>not</strong> modify
the raw data.  If you need to, then you should consider using derived
evidence.</p>
<p>This is a list of modifications that are completely forbidden:</p>
<ul class="simple">
<li><p>Adding live-generated data that does not come from the source.</p></li>
<li><p>Applying <cite>check-like</cite> logic (e.g. your data update if it includes an
<cite>if</cite>). Checks should test the evidence, not fetchers.</p></li>
</ul>
<section id="evidence-validation">
<h3>Evidence Validation<a class="headerlink" href="#evidence-validation" title="Permalink to this headline">¶</a></h3>
<p>A fetcher should only fetch data and store that data as evidence if the
current version of that evidence is stale (<code class="docutils literal notranslate"><span class="pre">ttl</span></code> has expired).  To that end
we’ve provided some helpful decorators and context managers that validate
<code class="docutils literal notranslate"><span class="pre">ttl</span></code> for you and if necessary write the evidence to the evidence locker for
you after it has been fetched.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">store_raw_evidence</span></code> and <code class="docutils literal notranslate"><span class="pre">store_tmp_evidence</span></code> decorators: Use one of
these decorators on your fetcher method when you know the path and name of
your raw or tmp evidence.  The decorator takes as an argument, the path to
your raw or tmp evidence as a string.</p></li>
</ul>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">store_raw_evidence</span>
<span class="o">...</span>
<span class="nd">@store_raw_evidence</span><span class="p">(</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">)</span>
<span class="n">fetch_foo_bar_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Fetcher code only executes if evidence is stale</span>
    <span class="c1"># Get the data from wherever</span>
    <span class="n">foo_bar_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_wherever</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="c1"># Return the content as a string</span>
    <span class="c1"># The decorator will write it to the evidence locker</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">foo_bar_data</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">raw_evidence</span></code> and <code class="docutils literal notranslate"><span class="pre">tmp_evidence</span></code> context managers: Use one of these
context managers within your fetcher method when your fetcher retrieves
multiple, similar raw or tmp evidence based on a dynamic set of configurable
values.  In other words the full name and content of evidence is based on a
configuration and not known prior to execution of the fetcher logic.  The
context manager takes as arguments, a locker object and the path to your raw
or tmp evidence as a string.  The context manager yields the corresponding
raw or tmp evidence object.</p></li>
</ul>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">raw_evidence</span>
<span class="o">...</span>
<span class="n">fetch_foo_bar_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">evidence_path</span> <span class="o">=</span> <span class="s1">&#39;foo/evidence_bar_</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">raw_evidence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locker</span><span class="p">,</span> <span class="n">evidence_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidence</span><span class="p">:</span>
            <span class="c1"># None is returned if evidence is not stale</span>
            <span class="k">if</span> <span class="n">evidence</span><span class="p">:</span>
                <span class="c1"># Get the data from wherever</span>
                <span class="n">foo_bar_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_wherever</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
                <span class="c1"># Set the content as a string</span>
                <span class="c1"># Upon exit it is written to the evidence locker</span>
                <span class="n">evidence</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">foo_bar_data</span><span class="p">))</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">store_derived_evidence</span></code> decorator: Use this decorator on your fetcher
method when you know the paths and names of your source evidences and
the path and name of your target derived evidence.  The decorator takes
as arguments, a list of source evidence paths as strings and a target derived
evidence path as a string.  It also passes the source evidences to the
decorated method in the form of method arguments.</p></li>
</ul>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">store_derived_evidence</span>
<span class="o">...</span>
<span class="nd">@store_derived_evidence</span><span class="p">(</span>
    <span class="p">[</span><span class="s1">&#39;raw/foo/evidence_bar.json&#39;</span><span class="p">,</span> <span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span><span class="p">],</span>
    <span class="s1">&#39;foo/derived_bar_baz.json&#39;</span>
<span class="p">)</span>
<span class="n">fetch_foo_bar_baz_derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bar_evidence</span><span class="p">,</span> <span class="n">baz_evidence</span><span class="p">):</span>
    <span class="c1"># Fetcher code only executes if evidence is stale</span>
    <span class="c1"># Construct your derived evidence</span>
    <span class="n">derived_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span><span class="n">bar_evidence</span><span class="p">,</span> <span class="n">baz_evidence</span><span class="p">)</span>
    <span class="c1"># Return the content as a string</span>
    <span class="c1"># The decorator will write it to the evidence locker</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">derived_data</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">derived_evidence</span></code> context manager: Use this context manager within your
fetcher method when your fetcher generates multiple, similar derived
evidences based on a dynamic set of configurable values.  In other words the
name and content of the evidences are based on a configuration and not
known prior to execution of the fetcher logic.  The context manager takes as
arguments, a locker object, source evidence paths and a target derived
evidence path as a string.  The source evidence paths can be in the form of a
list of paths as strings, a dictionary of key/values pairs as strings where
the key is an evidence short name and the value is the evidence path, or
simply a single evidence path as a string.  The context manager yields a
dictionary containing the source and target evidences as the dictionary
values.  The source evidence key is its evidence path if a list of source
paths were provided or its evidence short name if a dictionary of paths were
provided or “source” if a single evidence path in the form of a string was
provided.  The target derived evidence key is always “derived”.</p></li>
</ul>
<p>Usage example (source list provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">derived_evidence</span>
<span class="o">...</span>
<span class="n">fetch_foo_bar_baz_derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;raw/foo/evidence_bar.json&#39;</span><span class="p">,</span> <span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span><span class="p">]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s1">&#39;foo/derived_bar_baz_</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locker</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidences</span><span class="p">:</span>
            <span class="c1"># None is returned if target evidence is not stale</span>
            <span class="k">if</span> <span class="n">evidences</span><span class="p">:</span>
                <span class="c1"># Construct your derived evidence</span>
                <span class="n">derived_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span>
                    <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;raw/foo/evidence_bar.json&#39;</span><span class="p">],</span>
                    <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># Set the content as a string</span>
                <span class="c1"># Upon exit it is written to the evidence locker</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;derived&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">derived_data</span><span class="p">))</span>
</pre></div>
</div>
<p>Usage example (source dictionary provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">derived_evidence</span>
<span class="o">...</span>
<span class="n">fetch_foo_bar_baz_derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="s1">&#39;raw/foo/evidence_bar.json&#39;</span><span class="p">,</span>
            <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span>
        <span class="p">}</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s1">&#39;foo/derived_bar_baz_</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locker</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidences</span><span class="p">:</span>
            <span class="c1"># None is returned if target evidence is not stale</span>
            <span class="k">if</span> <span class="n">evidences</span><span class="p">:</span>
                <span class="c1"># Construct your derived evidence</span>
                <span class="n">derived_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span>
                    <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">],</span>
                    <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># Set the content as a string</span>
                <span class="c1"># Upon exit it is written to the evidence locker</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;derived&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">derived_data</span><span class="p">))</span>
</pre></div>
</div>
<p>Usage example (source string provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">derived_evidence</span>
<span class="o">...</span>
<span class="n">fetch_foo_bar_derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s1">&#39;raw/foo/evidence_bar.json&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="s1">&#39;foo/derived_bar_</span><span class="si">{}</span><span class="s1">.json&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">derived_evidence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locker</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidences</span><span class="p">:</span>
            <span class="c1"># None is returned if target evidence is not stale</span>
            <span class="k">if</span> <span class="n">evidences</span><span class="p">:</span>
                <span class="c1"># Construct your derived evidence</span>
                <span class="n">derived_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span><span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">])</span>
                <span class="c1"># Set the content as a string</span>
                <span class="c1"># Upon exit it is written to the evidence locker</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;derived&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">derived_data</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="evidence-dependency-chaining">
<h3>Evidence Dependency Chaining<a class="headerlink" href="#evidence-dependency-chaining" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a fetcher needs evidence gathered by another fetcher in order to
perform its fetching operation.  For example, a fetcher may need to collect
hardware/software inventory based on certain accounts/environments gathered by
another fetcher or fetchers.  Since order of execution cannot be guaranteed, it
is possible that a dependent fetcher (inventory) will run prior to the fetcher
that gathers the (accounts/environments) evidence that it depends on.  In
order to ensure that dependent evidence is always gathered, use the
<code class="docutils literal notranslate"><span class="pre">evidence.get_evidence_dependency</span></code> helper function in the dependent fetcher to
access the evidence that the fetcher depends on.  Using this function
ensures re-execution of the fetcher in the event that the dependent evidence has
not yet been populated/refreshed due to fetcher order of execution.  Once all
fetchers have executed, the framework will re-execute all fetchers that failed
due to an unavailable evidence dependency.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_evidence_dependency</span></code> usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">store_raw_evidence</span><span class="p">,</span> <span class="n">get_evidence_dependency</span>
<span class="o">...</span>
<span class="nd">@store_raw_evidence</span><span class="p">(</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">)</span>
<span class="n">fetch_foo_bar_evidence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">baz_evidence</span> <span class="o">=</span> <span class="n">get_evidence_dependency</span><span class="p">(</span>
        <span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locker</span>
    <span class="p">)</span>
    <span class="n">foo_bar_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_wherever_using_baz</span><span class="p">(</span><span class="n">baz_evidence</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">foo_bar_data</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="fetcher-execution">
<h3>Fetcher Execution<a class="headerlink" href="#fetcher-execution" title="Permalink to this headline">¶</a></h3>
<p>By default the Auditree framework will run all fetchers (tests prefixed by
<code class="docutils literal notranslate"><span class="pre">fetch_</span></code>) that it can find.  However, it is possible to limit fetcher
execution in bulk by using the <code class="docutils literal notranslate"><span class="pre">--include</span></code> and/or <code class="docutils literal notranslate"><span class="pre">exclude</span></code> CLI options
while providing a file path/name to a JSON config file containing a list of
fetchers to include/exclude.  The format of the JSON config file is a list of
fetcher classes.  Where a fetcher class is represented as a string dot notation
path to the fetcher class.</p>
<p>Fetcher include/exclude JSON config file example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
  <span class="s2">&quot;fetcher_pkg.path_to_my_checks.checks.fetch_module_foo.FooFetcherClass&quot;</span><span class="p">,</span>
  <span class="s2">&quot;fetcher_pkg.path_to_my_checks.checks.fetch_module_bar.BarFetcherClass&quot;</span>
<span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="compliance-checks">
<h2>Compliance Checks<a class="headerlink" href="#compliance-checks" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="compliance.html#compliance.check.ComplianceCheck" title="compliance.check.ComplianceCheck"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplianceCheck</span></code></a> is the parent class of
any set of checks that should be executed by the system. The run-time engine
will collect all the checks and run them when the <code class="docutils literal notranslate"><span class="pre">--check</span></code> option is
provided on the command line.</p>
<p>Checks <em>assume</em> that all evidence is retrieved by fetchers.  Consequently
checks <strong>should not</strong> be used to retrieve or store any <code class="docutils literal notranslate"><span class="pre">RawEvidence</span></code> in the
evidence locker. Each check class may have from one to multiple checks defined
(that is, a check is a method prefixed with <code class="docutils literal notranslate"><span class="pre">test_</span></code> in a check class). Each of
these checks will be executed by the Auditree framework with the following
possible results:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">OK</span></code>: the check ran successfully and <strong>passed</strong> all validations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WARN</span></code>: the check ran successfully but issued <strong>warnings</strong> based on
validation results.  A warning can represent a possible failure in the
future.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FAIL</span></code>: the check ran successfully but <strong>did not pass</strong> all validations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ERROR</span></code>: the check stopped abruptly and was not able to complete all
validations.</p></li>
</ul>
<section id="id2">
<h3>Evidence Validation<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>A check should only perform operations on evidence if the current version of
that evidence is not stale (<code class="docutils literal notranslate"><span class="pre">ttl</span></code> has not expired).  To that end
we’ve provided some helpful decorators and context managers that validate
<code class="docutils literal notranslate"><span class="pre">ttl</span></code> for you and will <code class="docutils literal notranslate"><span class="pre">ERROR</span></code> the check if evidence <code class="docutils literal notranslate"><span class="pre">ttl</span></code> has expired
prior to executing the check’s logic.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">with_raw_evidences</span></code>, <code class="docutils literal notranslate"><span class="pre">with_derived_evidences</span></code>, <code class="docutils literal notranslate"><span class="pre">with_tmp_evidences</span></code>,
and <code class="docutils literal notranslate"><span class="pre">with_external_evidences</span></code> decorators: Use these decorators on your
check method when you know the path and name of your raw, derived, tmp or
external evidence.  Each decorator takes as arguments, the paths to your  evidence as strings or as evidence <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuples.  Evidence
<code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> has <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">ev_class</span></code> (evidence class) as attributes.
If the requested evidence pass TTL validation the evidence is then passed
along to the decorated method in the form of method arguments.  Use an
evidence <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> when dealing with sub-classed <code class="docutils literal notranslate"><span class="pre">RawEvidence</span></code>,
<code class="docutils literal notranslate"><span class="pre">DerivedEvidence</span></code>, <code class="docutils literal notranslate"><span class="pre">TmpEvidence</span></code>, or <code class="docutils literal notranslate"><span class="pre">ExternalEvidence</span></code>, and you want
the evidence provided to the decorated method to be cast as that sub-classed
evidence otherwise use a string path and the evidence will be provided as
the appropriate base evidence.  A <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuple can be
constructed by executing the <code class="docutils literal notranslate"><span class="pre">lazy_load</span></code> class method of any evidence
class such as <code class="docutils literal notranslate"><span class="pre">BarEvidence.lazy_load('foo/evidence_bar.json')</span></code>.</p></li>
</ul>
<p>Usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">with_raw_evidences</span>
<span class="kn">from</span> <span class="nn">my_pkg.bar_evidence</span> <span class="kn">import</span> <span class="n">BarEvidence</span>
<span class="o">...</span>
<span class="nd">@with_raw_evidence</span><span class="p">(</span>
    <span class="n">BarEvidence</span><span class="o">.</span><span class="n">lazy_load</span><span class="p">(</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">),</span>
    <span class="s1">&#39;foo/evidence_baz.json&#39;</span>
<span class="p">)</span>
<span class="n">test_bar_vs_baz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bar_evidence</span><span class="p">,</span> <span class="n">baz_evidence</span><span class="p">):</span>
    <span class="c1"># Check code only executes if evidence is not stale.</span>
    <span class="c1"># Perform your check logic</span>
    <span class="n">failures</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">successes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span>
        <span class="n">bar_evidence</span><span class="p">,</span> <span class="n">baz_evidence</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_failures</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_warnings</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">warnings</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_successes</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">successes</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">evidences</span></code> context manager: Use this context manager within your
check method when your check method acts on multiple, similar evidence
based on a dynamic set of configurable values.  In other words the full name
and content of evidence is based on a configuration and not known prior
to execution of the check logic.  The context manager takes as arguments, the
check (<code class="docutils literal notranslate"><span class="pre">self</span></code>) object and either evidence paths strings or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code>
named tuples.  Evidence <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> has <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">ev_class</span></code>
(evidence class) as attributes.  The evidence arguments can be in the form of
a list of paths as strings or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuples, a dictionary of
key/values pairs where the key is an evidence short name and the value is the
evidence path as a string or a <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuple, or simply a single
evidence path as a string or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuple.  The context manager
yields a dictionary containing the evidence as the dictionary values if a
list or dictionary of evidence paths or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuples are
provided and yields an evidence object if a single evidence path as a string
or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuple is provided.  When a dictionary is yielded by
the context manager, the evidence key is its evidence path if a list of
evidence paths or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuples were provided or its evidence
short name if a dictionary of evidence paths or <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuples
were provided.  A <code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> named tuple can be constructed by executing
the <code class="docutils literal notranslate"><span class="pre">lazy_load</span></code> class method of any evidence class such as
<code class="docutils literal notranslate"><span class="pre">BarEvidence.lazy_load('foo/evidence_bar.json')</span></code>.</p></li>
</ul>
<p>Usage example (list provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">evidences</span>
<span class="kn">from</span> <span class="nn">my_pkg.bar_evidence</span> <span class="kn">import</span> <span class="n">BarEvidence</span>
<span class="o">...</span>
<span class="n">test_bar_vs_baz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">evidence_paths</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">BarEvidence</span><span class="o">.</span><span class="n">lazy_load</span><span class="p">(</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">),</span>
            <span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span>
        <span class="p">]</span>
        <span class="k">with</span> <span class="n">evidences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evidence_paths</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidences</span><span class="p">:</span>
            <span class="c1"># Check code only executes if evidence is not stale.</span>
            <span class="c1"># Perform your check logic</span>
            <span class="n">failures</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">successes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">],</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_failures</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_warnings</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">warnings</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_successes</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">successes</span><span class="p">)</span>
</pre></div>
</div>
<p>Usage example (dictionary provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">evidences</span>
<span class="kn">from</span> <span class="nn">my_pkg.bar_evidence</span> <span class="kn">import</span> <span class="n">BarEvidence</span>
<span class="o">...</span>
<span class="n">test_bar_vs_baz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">evidence_paths</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="n">BarEvidence</span><span class="o">.</span><span class="n">lazy_load</span><span class="p">(</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">),</span>
            <span class="s1">&#39;baz&#39;</span><span class="p">:</span> <span class="s1">&#39;raw/foo/evidence_baz.json&#39;</span>
        <span class="p">}</span>
        <span class="k">with</span> <span class="n">evidences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evidence_paths</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidences</span><span class="p">:</span>
            <span class="c1"># Check code only executes if evidence is not stale.</span>
            <span class="c1"># Perform your check logic</span>
            <span class="n">failures</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">successes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">],</span>
                <span class="n">evidences</span><span class="p">[</span><span class="s1">&#39;baz&#39;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_failures</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_warnings</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">warnings</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_successes</span><span class="p">(</span><span class="s1">&#39;bar vs. baz&#39;</span><span class="p">,</span> <span class="n">successes</span><span class="p">)</span>
</pre></div>
</div>
<p>Usage example (string path provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">evidences</span>
<span class="o">...</span>
<span class="n">test_bar_stuff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">evidence_path</span> <span class="o">=</span> <span class="s1">&#39;raw/foo/evidence_bar.json&#39;</span>
        <span class="k">with</span> <span class="n">evidences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evidence_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidence</span><span class="p">:</span>
            <span class="c1"># Check code only executes if evidence is not stale.</span>
            <span class="c1"># Perform your check logic</span>
            <span class="n">failures</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">successes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span><span class="n">evidence</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_failures</span><span class="p">(</span><span class="s1">&#39;bar stuff&#39;</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_warnings</span><span class="p">(</span><span class="s1">&#39;bar stuff&#39;</span><span class="p">,</span> <span class="n">warnings</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_successes</span><span class="p">(</span><span class="s1">&#39;bar stuff&#39;</span><span class="p">,</span> <span class="n">successes</span><span class="p">)</span>
</pre></div>
</div>
<p>Usage example (<code class="docutils literal notranslate"><span class="pre">LazyLoader</span></code> provided):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kn">from</span> <span class="nn">compliance.evidence</span> <span class="kn">import</span> <span class="n">evidences</span>
<span class="kn">from</span> <span class="nn">my_pkg.bar_evidence</span> <span class="kn">import</span> <span class="n">BarEvidence</span>
<span class="o">...</span>
<span class="n">test_bar_stuff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">systems</span><span class="p">:</span>
        <span class="n">lazy_evidence</span> <span class="o">=</span> <span class="n">BarEvidence</span><span class="o">.</span><span class="n">lazy_load</span><span class="p">(</span><span class="s1">&#39;foo/evidence_bar.json&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">evidences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lazy_evidence</span><span class="p">)</span> <span class="k">as</span> <span class="n">evidence</span><span class="p">:</span>
            <span class="c1"># Check code only executes if evidence is not stale.</span>
            <span class="c1"># Perform your check logic</span>
            <span class="n">failures</span><span class="p">,</span> <span class="n">warnings</span><span class="p">,</span> <span class="n">successes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_whatever</span><span class="p">(</span><span class="n">evidence</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_failures</span><span class="p">(</span><span class="s1">&#39;bar stuff&#39;</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_warnings</span><span class="p">(</span><span class="s1">&#39;bar stuff&#39;</span><span class="p">,</span> <span class="n">warnings</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_successes</span><span class="p">(</span><span class="s1">&#39;bar stuff&#39;</span><span class="p">,</span> <span class="n">successes</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="check-execution">
<h3>Check Execution<a class="headerlink" href="#check-execution" title="Permalink to this headline">¶</a></h3>
<p>The Auditree framework executes checks (tests prefixed by <code class="docutils literal notranslate"><span class="pre">test_</span></code>) based
on accreditation groupings defined in a <code class="docutils literal notranslate"><span class="pre">controls.json</span></code> config file.
This is especially useful when targeting check result content to the
appropriate groups of people.  The framework will by default look for
<code class="docutils literal notranslate"><span class="pre">controls.json</span></code> in the current directory.  It is possible to supply the
framework with alternate <code class="docutils literal notranslate"><span class="pre">controls.json</span></code> location(s) by providing an
alternate path or paths at the end of a compliance check execution command via
the CLI.  In the case of multiple locations, the framework will combine the
content of all <code class="docutils literal notranslate"><span class="pre">controls.json</span></code> files found together.  With this check to
accreditation mapping, the framework can execute checks based on the
accreditations passed to the framework by the CLI.</p>
<p><code class="docutils literal notranslate"><span class="pre">controls.json</span></code> content format example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;chk_pkg.chk_cat_foo.checks.chk_module_foo.FooCheckClass&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;accred.one&quot;</span><span class="p">],</span>
  <span class="s2">&quot;chk_pkg.chk_cat_bar.checks.chk_module_bar.BarCheckClass&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;accred.one&quot;</span><span class="p">,</span> <span class="s2">&quot;accred.two&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="fixers">
<h2>Fixers<a class="headerlink" href="#fixers" title="Permalink to this headline">¶</a></h2>
<p>After checks have been run, but before notifications or reports are
generated, the Auditree framework will optionally try to fix the
issues automatically. This is controlled with the <code class="docutils literal notranslate"><span class="pre">--fix</span></code> option.
By default it is <code class="docutils literal notranslate"><span class="pre">off</span></code>, and this is the mode that is used during the
daily CI runs in Travis. But you can also set it to <code class="docutils literal notranslate"><span class="pre">dry-run</span></code> or <code class="docutils literal notranslate"><span class="pre">on</span></code>.</p>
<p>In dry-run mode, the fixes are not actually run, but instead a message
is printed out for each fix indicating what action would be attempted.</p>
<p>When fixes are run for real, they will attempt to perform the actions
listed in dry-run mode. If the fix succeeds, then a counter
<code class="docutils literal notranslate"><span class="pre">fixed_failure_count</span></code> will be incremented. This counter is displayed
in the notification message.</p>
<p>See <a class="reference internal" href="fixers.html#fixers"><span class="std std-ref">Fixers</span></a> section for more information.</p>
</section>
<section id="report-builder">
<h2>Report Builder<a class="headerlink" href="#report-builder" title="Permalink to this headline">¶</a></h2>
<p>Once the execution of all checks and (optionally) fixers have been
executed, the <a class="reference internal" href="compliance.html#compliance.report.ReportBuilder" title="compliance.report.ReportBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReportBuilder</span></code></a> generates
reports by inspecting each check and storing the results in the
locker. These reports are useful for providing detailed information
regarding what failures were found.</p>
<p>See <a class="reference internal" href="report-builder.html#report-builder"><span class="std std-ref">Report Builder</span></a> section for more information.</p>
</section>
<section id="notifiers">
<h2>Notifiers<a class="headerlink" href="#notifiers" title="Permalink to this headline">¶</a></h2>
<p>After reports have been generated, the tool will collect notification
messages from them and will create a
<code class="xref py py-class docutils literal notranslate"><span class="pre">_BaseNotifier</span></code> object which deals with the
specific notification mechanism (e.g. send Slack message, print
messages to stdout, etc).</p>
<p>See <a class="reference internal" href="notifiers.html#notifiers-description"><span class="std std-ref">Notifiers</span></a> section for more information.</p>
</section>
<section id="execution-config">
<h2>Execution Config<a class="headerlink" href="#execution-config" title="Permalink to this headline">¶</a></h2>
<p>The Auditree framework is designed to be run locally from your PC or from
a CI server like Jenkins or Travis. The execution can be tweaked at 2
levels:</p>
<ul class="simple">
<li><p>Command line arguments: the tool accepts to be configured through
the command line for most important bits (evidence repo location,
notification mode, etc.)</p></li>
<li><p>Component specific: by using JSON files and <code class="docutils literal notranslate"><span class="pre">-C</span></code> option, you can
specify configuration values for different components. For instance,
if you use <code class="docutils literal notranslate"><span class="pre">--notify</span> <span class="pre">slack</span></code>, then you can configure this component
to send notifications to different people/channels based on the
accreditation. See <a class="reference internal" href="notifiers.html#notifiers-description"><span class="std std-ref">Notifiers</span></a> section to see this
example.</p></li>
</ul>
</section>
<section id="credentials">
<span id="id3"></span><h2>Credentials<a class="headerlink" href="#credentials" title="Permalink to this headline">¶</a></h2>
<p>If you want to configure your credentials locally, the framework
will look for a credentials file at <code class="docutils literal notranslate"><span class="pre">~/.credentials</span></code> by default. This
file should be similar to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- mode:conf -*-</span>

<span class="c1"># Token for github.com to be used by the Locker</span>
<span class="p">[</span><span class="n">github</span><span class="p">]</span>
<span class="n">token</span><span class="o">=</span><span class="n">XXX</span>

<span class="c1"># Webhook for Slack notifications</span>
<span class="p">[</span><span class="n">slack</span><span class="p">]</span>
<span class="n">webhook</span><span class="o">=</span><span class="n">XXX</span>
<span class="c1"># token=XXX  # can be used instead of webhook</span>

<span class="c1"># Token for PagerDuty notifications</span>
<span class="p">[</span><span class="n">pagerduty</span><span class="p">]</span>
<span class="n">api_key</span><span class="o">=</span><span class="n">XXX</span>
<span class="n">events_integration_key</span><span class="o">=</span><span class="n">XXX</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Design Principles</a><ul>
<li><a class="reference internal" href="#evidence">Evidence</a></li>
<li><a class="reference internal" href="#evidence-locker">Evidence Locker</a></li>
<li><a class="reference internal" href="#compliance-fetchers">Compliance Fetchers</a><ul>
<li><a class="reference internal" href="#evidence-validation">Evidence Validation</a></li>
<li><a class="reference internal" href="#evidence-dependency-chaining">Evidence Dependency Chaining</a></li>
<li><a class="reference internal" href="#fetcher-execution">Fetcher Execution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compliance-checks">Compliance Checks</a><ul>
<li><a class="reference internal" href="#id2">Evidence Validation</a></li>
<li><a class="reference internal" href="#check-execution">Check Execution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fixers">Fixers</a></li>
<li><a class="reference internal" href="#report-builder">Report Builder</a></li>
<li><a class="reference internal" href="#notifiers">Notifiers</a></li>
<li><a class="reference internal" href="#execution-config">Execution Config</a></li>
<li><a class="reference internal" href="#credentials">Credentials</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="quick-start.html"
                        title="previous chapter">Quick Start</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="oscal.html"
                        title="next chapter">OSCAL Support</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/design-principles.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="oscal.html" title="OSCAL Support"
             >next</a> |</li>
        <li class="right" >
          <a href="quick-start.html" title="Quick Start"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Auditree Framework 1.21.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Design Principles</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, IBM.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>